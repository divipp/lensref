% Introduction to state-based FRP
% *Draft*


# Motivation

## Stream-based FRP

Interactive programs can be described as stream transformers.
For example, interactive programs with a graphical user interface (GUI) can be described
as stream transformers with keyboard and mouse events as input streams
and a continuously changing screen as an output stream:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    box [label = "stream\ntransformer", shape = rect]
    node [style = invis, shape= point]
    mouse -> box [label="mouse\nevents"]
    keyboard -> box [label="keyboard\nevents"]
    box -> screen [label="screen\nstream"]
}
~~~~~~~~

The goal of *functional reactive programming* (FRP) is to declaratively describe
interactive programs. Declarative descriptions are composable which
means that FRP descriptions of interactive
programs can be decomposed into FRP descriptions of simpler interactive programs.

Most declarative descriptions of interactive programs is built around
event streams and stream transformers equipped with different
combinators like horizontal and vertical composition.
Let us call these systems *stream-based FRP* systems.


## State-based FRP

Stream-based FRP is not the only possible way to declaratively describe interactive programs.

In case of interactive programs with a GUI it is possible to describe the program state,
to describe how mouse and keyboard events alter the program state and
to project the program state onto the screen:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    box [label = "program\nstate", shape=ellipse]
    screen [label = "screen"]
    node [style = invis, shape= point]
    box -> box [label=""]
    box -> box [label="mouse events\nkeyboard events"]
    box -> screen [label="projection"]
}
~~~~~~~~

It is not obvious to generalize this scheme to arbitrary
interactive programs, and to decompose it into simpler similar parts.
Let us call *state-based FRP* a system characterized by this goal.

State-based FRP is an alternative to stream-based FRP systems.
In many cases, state-based FRP decomposition of interactive programs is simpler
than their stream-based FRP decomposition.

This document gives an introduction to state-based FRP as implemented
in the `lensref` package[^lensref].

[^lensref]: [http://hackage.haskell.org/package/lensref](http://hackage.haskell.org/package/lensref)



# Basic operations on references

The interface of `lensref` is built around the reference data type.
This section defines an interface of basic reference operations. We
add new operations step-by-step to this interface in the following sections.

## The reference data type

A *reference* is an editable view of the program state.

Each reference has a *context*. The context tells
what kind of effects may happen during reference write, for example.
It also helps to distinguish references created in different regions.
Not every reference context is valid; the `RefContext` type class classifies
valid reference contexts:

> -- reference contexts
> class Monad m => RefContext m
>
> instance RefContext IO
> instance RefContext (ST s)
> instance RefContext m => RefContext (ReaderT r m)
> instance (RefContext m, Monoid w) => RefContext (WriterT w m)
> ...

A reference has an associated *value* for each program state.

The type of a reference is determined by the type of its context and the type of its values:

> -- abstract data type of references
> data RefContext m => Ref m a

## Interface of the basic operations

The basic reference operations are *reference reading*,
*reference writing* and *reference creation*.
The interface of the basic reference operations is the following:

> -- reference read action
> readRef  :: RefContext m =>  Ref m a -> RefReader m a
> -- reference write action
> writeRef :: RefContext m =>  Ref m a -> a -> RefWriter m ()
> -- new reference creation action
> newRef   :: RefContext m =>  a -> RefCreator m (Ref m a)
>
> data RefReader  m a  -- reference reader computation
> data RefWriter  m a  -- reference writer computation
> data RefCreator m a  -- reference creator computation
>
> instance RefContext m => Monad (RefReader m)
> instance RefContext m => Monad (RefWriter m)
> instance RefContext m => Monad (RefCreator m)
>
> instance MonadTrans RefWriter
> instance MonadTrans RefCreator
>
> readerToWriter  :: RefContext m => RefReader m a -> RefWriter  m a
> readerToCreator :: RefContext m => RefReader m a -> RefCreator m a

Reference reading returns the value of a reference for any program state.
Given a reference `(r :: Ref m a)` and a value `(x :: a)`,
reference writing changes the program state such that the value of `r` in
the changed state will be `x`.[^write]
Given a value `(x :: a)`, new reference creation extends the program state with
a new `a`-typed field initialized with `x`
and returns a reference whose value is always the value of the new field in the program state.

[^write]: This is an incomplete definition of reference writing because
it does not define how reference writing changes the values of other references.
We leave this question open for now.

Reference reader, writer and creator computations are abstract data types with `Functor`, `Applicative` and `Monad` instances
(declaration of `Functor` and `Applicative` instances was left implicit for brevity).
`RefWriter` and `RefCreator` are monad transformers. `RefReader` is
not a monad transformer because no side effect is allowed during reference reading.

Reference writer and creator computations may involve reference reader computations:
`readerToWriter` lifts reference reader computations to reference writer computations;
`readerToCreator` lifts reference reader computations to reference creator computations.

The distinction between `RefReader`, `RefWriter` and `RefCeator` is necessary
for operations introduced later.


## Laws

The following laws are part of the interface.

### Law 1: write-read

Let `(r :: Ref m a)` be a reference and `(x :: a)` a value.
Reading `r` after writing `x` into it returns `x`, i.e.
the following expressions have the same behaviour:[^behaviour]

~~~~~ {.haskell}
writeRef r x >> readerToWriter (readRef r)
    ~       -- write-read
writeRef r x >> return x
~~~~~

[^behaviour]: We say that two expressions has the same behaviour if they are
replaceable in any context without changing the functional properties of the program
(difference in resource usage is possible).

The write-read law is analogue to the set-get law for lenses.
The following laws which are analogue to the get-set and set-set lens laws are **not required** in the `lensref` library.

The read-write law is **not required**:

~~~~~ {.haskell}
readerToWriter (readRef r) >>= writeRef r
    ~       -- read-write
return ()
~~~~~

The write-write law is **not required**:

~~~~~ {.haskell}
writeRef r x' >> writeRef r x
    ~       -- write-write
writeRef r x
~~~~~


### Law 2: `RefReader` has no side effects

Let `(m :: RefReader m a)`. `m` has no side effects, i.e.
the following expressions have the same behaviour:

~~~~~ {.haskell}
m >> return ()
    ~       -- RefReader-no-side-effect
return ()
~~~~~


### Law 3: `RefReader` is idempotent

Let `(m :: RefReader m a)`. Multiple execution of `m` is the same as one execution of `m`, i.e.
the following expressions have the same behaviour:

~~~~~ {.haskell}
liftM2 (,) m m
    ~       -- RefReader-idempotent
liftM (\a -> (a, a)) m
~~~~~

Laws 2 and 3 together implies that `RefReader` has no effects,
i.e. it is isomorphic to the `Reader` monad.[^indep]

[^indep]: [http://stackoverflow.com/questions/16123588/what-is-this-special-functor-structure-called](http://stackoverflow.com/questions/16123588/what-is-this-special-functor-structure-called)


### Law 4: `RefCreator` has no extra side effects

Let `(c :: RefCreator m a)`. `c` has no side effects if `m` has no side effects, i.e.
if

~~~~~ {.haskell}
m >> return ()
    ~
return ()
~~~~~

holds for all `(m :: m)` then

~~~~~ {.haskell}
c >> return ()
    ~       -- RefCreator-no-side-effect
return ()
~~~~~

Law 4 is similar to law 2 but stated for the `RefCreator` monad instead of `RefReader`
and with and extra condition for the reference context.

Note unlike `RefReader`, `RefCreator` is not idempotent.
For example, `(liftM2 (,) (newRef 14) (newRef 14))` and
`(liftM (\a -> (a, a)) (newRef 14))` has different behaviour since
the former creates two distinct references whilst the latter creates two entangled references.

## Derived construct: `modRef`

> modRef :: RefContext m => Ref m a -> (a -> a) -> RefWriter m ()
> modRef r f = readerToWriter (readRef r) >>= writeRef r . f


## Running `RefCreator`

`lensref` exposes the following function:

> runRefCreator
>     :: RefContext m
>     => ((forall b . RefWriter m b -> m b) -> RefCreator m a)
>     -> m a

`runRefCreator` turns a `(RefCreator m a)` computation into an `(m a)` computation.
During the creation of the `(RefCreator m a)` value it is allowed
to turn any `(RefWriter m b)` computation into an `(m a)` computation.

### Safety of `runRefCreator`

This subsection is a note for the curious.

`runRefCreator` is an unsafe function, it is possible to implement a restricted form of
`unsafeCoerce` with it, for example.
`lensref` exposes `runRefCreator` because of the following reasons:

-   There is a trade-off between the safety of `runRefCreator` and the complexity of its interface.
-   There are two easy rules to follow to keep the current `runRefCreator` safe:
    -   Call `runRefCreator` only once in your program.
        `lensref` is designed such that one call of `runRefCreator` is enough in most use cases.
    -   Use `runRefCreator` in a single-threaded environment.
-   A thread-safe variant and/or a
    multiple-call-safe variant of `runRefCreator` can be defined in terms of the current
    `runRefCreator` function. See ... TODO


## Examples

For basic usage examples we use a specialized form of `runRefCreator`:

> runRefTest :: (forall s . RefCreator (ST s) (RefWriter (ST s) a)) -> a
> runRefTest m
>     = runST $ join $ runRefCreator $ \runRW -> m <&> runRW

Note that `runRefTest` is a safe function (unlike `runRefCreator`).

> -- readTest == 3
> readTest = runRefTest $ do
>     r <- newRef (3 :: Int)
>     return $ readerToWriter (readRef r)

> -- writeTest == 4
> writeTest = runRefTest $ do
>     r <- newRef (3 :: Int)
>     return $ do
>         writeRef r 4
>         readerToWriter (readRef r)

Nothing special so far.


# References connected by lenses

## Lenses summary

We use Edward Kmett's lens notation.
The needed definitions from the `lens` package are the following:

> -- data type for lenses (simplified form)
> type Lens' a b
>
> -- lens construction with get+set parts
> lens :: (a -> b) -> (a -> b -> a) -> Lens' a b
>
> -- the get part of a lens, arguments flipped
> (^.) :: a -> Lens' a b -> b
>
> -- the set part of a lens, arguments flipped
> set :: Lens' a b -> b -> a -> a
>
> -- data type for isomorphisms (simplified form)
> type Iso' a b
>
> -- iso construction with to+from parts
> iso :: (a -> b) -> (b -> a) -> Iso' a b
>
> -- lens from anything to unit
> united :: Lens' a ()
>
> -- ad-hoc polymorphic tuple element lenses
> _1 :: Lens' (x, y) x
> _1 :: Lens' (x, y, z) x
> _1 :: ...
> _2 :: Lens' (x, y) y
> _2 :: Lens' (x, y, z) y
> _2 :: ...
> _3 :: Lens' (x, y, z) z
> _3 :: Lens' (x, y, z, v) z
> _3 :: ...
> ...
>
> -- function composition can be used for lens composition
> (.) :: Lens' a b -> Lens' b c -> Lens' a c
>
> -- conversion from isomorphisms to lenses is implicit
> id :: Iso' a b -> Lens' a b
>
> -- id is the identity isomorphism (and a lens too)
> id :: Iso' a a

Utility functions used:

> -- flipped fmap
> <&> :: Functor f => f a -> (a -> b) -> f b


### Use of improper lenses

Let `(k :: Lens' A B)`, `(a :: A)`, `(b :: B)` and `(b' :: B)`.
Edward Kmett's three common sense lens laws are the following:

~~~~~ {.haskell}
set k b a ^. k        ==  b            -- set-get
set k (a ^. k) a      ==  a            -- get-set
set k b (set k b' a)  ==  set k b a    -- set-set
~~~~~

The `lensref` library can deal with lenses which do not satisfy the
get-set or the set-set laws.
`lensref` calls these lenses improper lenses and uses the same `Lens'` type
for them.


## Lens application

We add lens application to the interface:

> -- lens-application
> lensMap :: Lens' a b -> Ref m a -> Ref m b

### Semantics of lens application

Let `(r :: Ref m a)` and `(k :: Lens' a b)`.
`(lensMap k r)` is characterized by the following laws:

-   ~~~~~ {.haskell}
    readRef (lensMap k r)
        ~       -- lensMap-read
    readRef r <&> (^. k)
    ~~~~~

-   For all `(y :: B)`

    ~~~~~ {.haskell}
    writeRef (lensMap k r) y
        ~       -- lensMap-write
    modRef r (flip (set k) y)
    ~~~~~

## Examples



## The `Ref` category

Let `(a :: Ref m A)` and `(b :: Ref m B)`.
We say that `a` and `b` are connected by `(k :: Lens' A B)` iff
the following holds:

~~~~~ {.haskell}
b
    ~
lensMap r a
~~~~~

Lens connection is a transitive relation, and
every reference is connected to itself by the `id` lens,
so references as objects and lens connections as morphisms form a category.
Let us call this category `Ref`.

Some properties of the `Ref` category:

-   Terminal object: `(r :: Ref m ())`
-   The program state is an initial object. It can not be typed in Haskell because
    new reference creation changes the type of the program state.
-   Pullbacks up to isomorphism?


# Reference diagrams

## `Hask` diagrams

We will draw diagrams in the `Hask` category.

In `Hask` types are objects and functions are arrows.

### Motivation

Why are `Hask` diagrams useful (compared to source code)?

-   Variable names are not needed.
-   Diagrams may show constraints, see the following diagrams.
-   The diagram may contain additional information.
    In the next section we decorate `Hask` diagrams to reflect
    information flow and GUI widget bindings, for example.

Constraints shown in diagrams:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    x [label = "Integer"]
    y [label = "Integer"]
    x -> y [label="f", constraint=false]
    y -> x [label="g", constraint=false]
}
~~~~~~~~

The diagram shows two `Integer`-typed variables in scope. Let us call them
`x` and `y`. The corresponding source code may be `{y = f x}` or `{x = g y}`
but both of them lacks a constraint shown on the diagram.

Another example:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    x [label = "Integer"]
    y [label = "Integer"]
    a [label = "Integer"]
    x -> a [label = "abs"]
    y -> a [label = "abs"]
}
~~~~~~~~

The diagram shows three `Integer`-typed variables in scope.
Let us call them `a`, `x` and `y` from up to down and left to right.
The diagram shows that `a ~ (abs x) ~ (abs y)` (the expressions have
the same behaviour) which cannot be expressed with source code.

### N-ary functions in diagrams

Usually n-ary functions are presented in uncurried form with a product domain:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    x [label = "Integer"]
    y [label = "Integer"]
    xy [label = "(Integer, Integer)"]
    a [label = "Bool"]
    b [label = "Bool"]
    xy -> x [label = "fst", constraint=false]
    xy -> y [label = "snd", constraint=false]
    xy -> a [label = "uncurry (==)"]
    a -> b [label = "not"]
}
~~~~~~~~

Instead of this we present n-ary functions with different kind of nodes,
so we have type nodes and function nodes in the diagram.
The direct predecessors of function nodes are the function arguments. 
The order of arguments matter so the input arrows of function nodes are numbered.
The previous diagram in this presentation:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    x [label = "Integer"]
    y [label = "Integer"]
    a [label = "Bool"]
    b [label = "Bool"]
    Node [margin=0, shape = none, width=0, height=0]
    x -> "==" [label = "1"]
    y -> "==" [label = "2"]
    "==" -> a
    a -> not [label = "1"]
    not -> b
}
~~~~~~~~

### Simplifications

We use several simplification to make the diagrams smaller:

-   A unary function may be presented as an arrow.
-   The label of a type node may be hidden if it is inferable.
-   A type node with a hidden label and with one input arrow may be hidden.
-   The numbering of the input arrows of function nodes may be hidden if it is inferable or the ordering does not matter.

The previous diagram with some of the simplifications applied:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    x [label = "Integer"]
    y [label = "Integer"]
    r [label = ""]
    Node [margin=0, shape = none, width=0, height=0]
    x -> "=="
    y -> "=="
    "==" -> r [label = "not"]
}
~~~~~~~~

## Reference-diagrams

We decorate `Hask` diagrams to reflect
information flow and GUI widget bindings.

There will be three different kind of decorations applied:

-   Edge style may not be plain in case of some special functions.
-   Layout of nodes may be significant.
-   Nodes may be clustered.

### Lens connection

Arrows representing `(lensMap _)` functions have
an inverted arrow tail to reflect bidirectional information flow between references:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    a [label = "Ref m a"]
    b [label = "Ref m b"]
    Edge [dir = both, arrowtail=inv]
    a -> b [label="lensMap (k :: Lens' a b)"]
}
~~~~~~~~

Moreover, the layout of the nodes is significant.
The rule is the following:

Let `r` and `q` be references or reference reader computations.
If there is an undirected path
between `ä` and `b` through references and reference reader computations, and `b` is not below `a`,
then the value of `b` is determined by the value of `a` for any program state.

For example, in case of a lens-connection by an isomorphism the references may be shown
at the same level to reflect that their values are determined by each-other:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    a [label = "Ref m A"]
    b [label = "Ref m B"]
    Edge [dir = both, arrowtail=inv]
    a -> b [label="lensMap (k :: Iso' A B)", constraint="false"]
}
~~~~~~~~

### `RefReader` computations

The layout rule applies for `RefReader` computations too.
An example:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    a [label = "Ref m Int"]
    Node [margin=0, shape = none, width=0, height=0]
    a -> readRef [constraint = false]
    readRef -> "fmap abs"
    "fmap abs" -> "fmap negate" [constraint = false]
    {rank=same; "fmap abs"; "fmap negate"}
}
~~~~~~~~

### `RefWriter` computations

Recall the type of `writeRef`:

> writeRef :: Ref m a -> a -> WriteRef m ()

`writeRef` can be generalized such that the written value is
a `RefReader` value:

> writeRefDyn :: Ref m a -> RefReader m a -> RefWriter m ()
> writeRefDyn r m = readerToWriter m >>= writeRef r

`writeRefDyn` alone is enough to construct the needed `RefWriter` computations in many cases.
The arrow of first argument of `writeRefDyn` is drawn
*backwards* and dotted to reflect that
value of the reference is updated occasionally:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    r [label = "Ref m a"]
    a [label = "RefReader m a"]
    Node [margin=0, shape = none, width=0, height=0]
    w [label = "writeRefDyn"]
    a -> w
    r -> w [dir = back, style = "dashed"]
}
~~~~~~~~


### Widget decorations

Groups of `Ref`, `RefReader` and `RefWriter` values can
be connected to GUI widgets.[^widgets]
This connections are shown as clustering decorations on reference diagrams.

[^widgets]: See the `lgtk` library which is based on `lensref`.

Possible connections are the following:

-   `(RefReader m String)` computations can be connected to dynamic labels.
    The label shows the actual return value of the computation.
-   `(Ref m Bool)` values can be connected to checkboxes.
    Iff the value of the reference is `True`, the checkbox is checked.
    Note that this describes a two-way connection between the checkbox and the program
    state (changing the program state may alter the checkbox and vice-versa).
-   References with basic types like `Int`, `Double` or `String` can be connected to entries.
-   `(RefWriter m ())` computations can be connected to buttons.
    When the button is pressed, the computation is executed.
-   `(RefReader m Bool)` computations can be attached to checkboxes, entries or buttons.
    The widgets are dynamically activated or deactivated whenever the computation returns `True` or `False`, respectively.
-   `(RefReader m String)` computations can be attached to buttons.
    The return value of the computation is shown as a dynamically changing button label.

For example, a Celsius-Fahrenheit converter has two entangled `Double` value entries:

~~~~~~~~ {.dot}
digraph G {
    Graph [labeljust = "l", labelloc = "b", fontcolor=gray, pencolor = gray]
    rankdir = BT
    Edge [dir = both, arrowtail=inv]
    b1 -> b2 [label="lensMap\ncelsiusToFahrenheit"; constraint="false"]
    subgraph cluster_entry1 {
        label = "entry"
        b1 [label = ""]
    }
    subgraph cluster_entry2 {
        label = "entry"
        b2 [label = ""]
    }
}
~~~~~~~~

> celsiusToFahrenheit :: Iso' Double Double
> celsiusToFahrenheit = multiplying 1.8 . adding 32


A simple counter has an integer label and a button (here the reference `c` was converted implicitly to a `RefReader`
value by `readRef`):

~~~~~~~~ {.dot}
digraph G {
    Graph [labeljust = "l", labelloc = "b", fontcolor=gray, pencolor = gray]
    rankdir = BT
    c [label = "Ref m Int"]
    Node [margin=0, shape = none, width=0, height=0]
    c -> cv [constraint=false]
    cv -> b [label = "fmap\n(+1)"]
    cv -> cvs [constraint=false]
    Edge [dir = back, style=dashed]
    c -> b
    cv [label = "readRef"]
    subgraph cluster_label {
        label = "label"
        cvs [label="fmap show"]
    }
    subgraph cluster_button {
        label = "button"
        b [label = "writeRefDyn"]
    }
}
~~~~~~~~

In a bit more complex example a `(Maybe Int)` value editor is shown.
Note that the primary reference is here `r`; the reference `q` is needed
to remember the entry value when the user deactivates and re-activates the entry
by clicking the checkbox twice.

~~~~~~~~ {.dot}
digraph G {
    Graph [labeljust = "l", labelloc = "b", fontcolor=gray, pencolor = gray]
    rankdir = BT
//    "main program state" -> "substate ::\nMaybe Int" [label = "k"]
    r [label = "Ref m (Bool, Int)"]
    q [label = "Ref m (Maybe Int)"]  
    Node [margin=0, shape = none, width=0, height=0]
    Edge [dir = both, arrowtail=inv]
    r -> q [xlabel = "lensMap\nmaybeLens"]
    r -> "checkbox"
    r -> entryActive [dir = "forward"]
    r -> entryValue
    subgraph cluster_checkbox {
        label = "checkbox"
        checkbox [label = "lensMap _1"]
        }
    subgraph cluster_entry {
        label = "entry"
        entryValue [label = "lensMap _2"]
        entryActive [label=<<FONT COLOR="grey">active</FONT><BR/>fmap fst . readRef>]
    }
}
~~~~~~~~

> -- improper lens: set-set law is violated
> maybeLens :: Lens' (Bool, a) (Maybe a)
> maybeLens = lens get set
>   where
>     get (True, a) = Just a
>     get _ = Nothing
>     set (_, a) = maybe (False, a) ((,) True)



# Reference-network creation

Arbitrary tree-shaped reference-network can be created with the following
two operations:

> -- lens-application
> lensMap :: Lens' a b -> Ref m a -> Ref m b
>
> -- backward lens-application (reference extension)
> extendRef :: Ref m b -> Lens' a b -> a -> RefCreator m (Ref m a)

Let `(k :: Lens' a b)` and `(r :: Ref m a)`.
Then `r` and `(lensMap k r)` are references connected by `k`.

Let `(q :: Ref m b)`, `(k :: Lens' a b)` and `(x :: a)`.
Let `(r :: Ref m a)` the return value of `(extendRef q k x)`.
Let *s* the program state before the creation of `r` and *s'* the program
state after the creation of `r`.
Then the following hold:

-   `r` and `q` are connected by `k`.
-   All references have the same value in *s'* as in *s* (with the exception of `r`
    whose value is not defined in *s*).
-   The value of `r` in *s'* is `(set k y x)` where `y` is the value
    of `q` in *s* (or in *s'*). Note that this is the most meaningful value
    for `r` such that the previous two statements hold.

Note that `extendRef` is needed for the creation of reference-networks like the
following:

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    Edge [dir = both, arrowtail=inv]
    a1 [label = "Ref m (Bool, Int)"]
    a2 [label = "Ref m (Bool, Int)"]
    b [label = "Ref m (Maybe Int)"]
    a1 -> b [label="lensMap\nmaybeLens"]
    a2 -> b [label="lensMap\nmaybeLens"]
}
~~~~~~~~

`extendRef` is called reference extension because the result reference
may contain more information than the original reference
(the value of the result reference is not determined by the value of
the original reference).



# Tracking changes in the reference-network

## Motivation


## Semantics

- currentValue
- instance Monad RefReader


# Dynamic networks

- RefReader m (Ref m a)
- onChange
- joinRef

# Resource handling

- onRegionStatusChange


# Old stuff

## How to apply a lens to an `IORef`?

Application of a lens to an `IORef` is only possible with a modified `IORef` definition:

> type IORef' a = (IO a, a -> IO ())

`IORef'`s still can be created, read and written:

> readIORef' :: IORef' a -> IO a
> readIORef' = fst

> writeIORef' :: IORef' a -> a -> IO ()
> writeIORef' = snd

> newIORef' :: a -> IO (IORef' a)
> newIORef' a = do
>     r <- newIORef a
>     return (readIORef r, writeIORef r)

Lens application is now also possible:

> lensMap :: Lens' a b -> IORef' a -> IORef' b
> lensMap (get, set) (read, write) =
>     ( fmap get read
>     , \b -> do
>          a <- read
>          write $ set a b
>     )

## Usage example

A simple example how to use `lensMap`:

> main = do
>     r <- newIORef' ((1,"a"),True)
>     let r' = lensMap (_1 . _2) r
>     writeIORef' r' "b"

The values of `r` and `r'` are connected: whenever `r` is written `r'` changes
and whenever `r'` is written `r` changes.
At any time the following holds:

> rv' = rv ^. _1 . _2

where `rv` and `rv'` are the actual values of `r` and `r'`, respectively.

## What is `lensMap` good for?

It seems natural that if we have a reference to a state,
we can build a reference to a substate of the state.
I claim that `lensMap` allows to write code easier to compose.
I give a try to verify my claim in the summary section.




# Joining a reference

By joining a reference I mean the following operation:

> joinRef :: IO (IORef' a) -> IORef' a

## What is `joinRef` good for?

Suppose we have `mb :: IO Bool` and `r1, r2 :: IORef' Int`.
With `joinRef` we can make a reference `r` which acts like `r1`
or `r2` depending on the *actual* value of `mb`.

> r :: IORef' Int
> r = joinRef $ do
>     b <- mb
>     return $ if b then r1 else r2

`joinRef` allows more than just switching between two references
dynamically. One can build a network of references with `lensMap` and
make this network fully dynamic with `joinRef`.

## Why is it called `joinRef`?

I call it `joinRef` because with another definition of `IORef'`, `Control.Monad.join` acts like `joinRef`!

> type IORef'' a = IO (a, a -> IO ())

`IORef''` is isomorphic to `IORef'`:

> convTo :: IORef' a -> IORef'' a
> convTo (read, write) = do
>     a <- read
>     return (a, write)

> convFrom :: IORef'' a -> IORef' a
> convFrom r =
>     ( fmap fst r
>     , \a -> do
>         (_, write) <- r
>         write a
>     )

`joinRef` is `join`:

> joinRef :: IO (IORef'' a) -> IORef'' a
> joinRef = join



# Backward application of a lens to a reference

By backward lens application I mean the following operation:

> extRef :: IORef' b -> Lens a b -> a -> IO (IORef' a)

## Why is it called `extRef`? How is it backward lens application?

It is called `extRef` because an existing program state can be *extended* with it.
Suppose that `r :: IORef' Int`. Suppose that we would like to double the possible
values of `r`, i.e. we would like to extend the state referenced by `r` with
a `Bool` value. We can do it with the following definition:

> r :: IORef' Int
> r = ...

> do
>     (r' :: IORef' (Int, Bool)) <- extRef r _1 (0, False)

The third parameter of `extRef` determines the initial value of `r'`. If
the value of `r` is `15` at the creation time of `r'` then the initial
value of `r'` is `(15, False)`.

The values of `r` and `r'` remain connected: whenever `r` is written `r'` changes
and whenever `r'` is written `r` changes.
The connection between `r` and `r'` is exactly the same as if `r'` was created
first and `r` was defined by

> r :: IORef' Int
> r = lensMap _1 r'

In this sense `extRef` is the inverse of `lensMap` and this is why I call it backward
lens application.



## Implementation of `extRef`

It turns out that `extRef` cannot be defined with the previous definitions of `IORef'`.
It can be defined on this modified `IORef'` data structure instead:

> data IORef''' a = IORef''
>     { readRef          :: IO a
>     , writeRef         :: a -> IO ()
>     , registerCallback :: IO () -> IO ()
>     }

`registerCallback` takes and `IO` action and stores it (there is one store per reference).
`writeRef` calls all the stored actions after setting the reference value.
We do not go into further details here.
The source code of a complete implementation can be found in ...


## Multiple monads for reference operations

The return type of `extRef` is `IO (IORef' a)` which
can be turned into `IORef' a` by `joinRef`:

> joinedExtRef :: IORef' b -> Lens a b -> a -> IORef' a
> joinedExtRef r k a = joinRef (extRef r k a)

In fact `joinedExtRef r k a` is quite useless and it behaves wrongly (setting its value
me have no effect).
We would like to disallow this combination of `extRef` and `joinRef`,
therefore we introduce different monad layers in which different reference actions are allowed.

So far the following three monad layers turned out to be handy to work with:

monad layer   allowed actions
------------- ----------------------------------
ReadRef       reference read
CreateRef     reference read and creation
WriteRef      reference read, creation and write
------------- ----------------------------------

From now on, we replace `IO` by either `ReadRef` or `CreateRef` or `WriteRef`.
We replace `IORef'` by `Ref` too.

In the new system `joinRef` has limited availability:

> joinRef :: ReadRef (Ref a) -> Ref a

The result of `extRef` is in the `CreateRef` monad:

> extRef :: Ref b -> Lens a b -> a -> CreateRef (Ref a)

Thus `joinRef` cannot be applied after `extRef` and the above puzzle is solved.


## `newRef` as a special case of `extRef`

Before making a summay, notice that
`extRef` is so strong that `newRef` can be expressed in terms of it:

> newRef :: a -> CreateRef (Ref a)
> newRef = extRef unitRef united

Here `unitRef` can be any reference which has type `Ref ()`.

We add `unitRef` to the set of basic reference operations (it is a constant):

> unitRef :: Ref ()


## Summary so far

The discussed data types and operations so far are the following:

> Ref       :: * -> *
> ReadRef   :: * -> *   -- instance of Monad
> CreateRef :: * -> *   -- instance of Monad
> WriteRef  :: * -> *   -- instance of Monad

> liftReadRef   :: ReadRef a   -> CreateRef a
> liftCreateRef :: CreateRef a -> WriteRef a

> unitRef  :: Ref ()
> lensMap  :: Lens' a b -> Ref a -> Ref b
> readRef  :: Ref a -> ReadRef a
> joinRef  :: ReadRef (Ref a) -> Ref a
> extRef   :: Ref b -> Lens' a b -> a -> CreateRef (Ref a)
> writeRef :: Ref a -> a -> WriteRef ()

`liftReadRef` is handy because during reference creation we can read existing references.

`liftCreateRef` is handy because during reference write we can create references
(a use case is to create a new reference and give it as a value of a reference-reference).


# Connecting events to reference change

This operation is the last big step into the direction of a fully working FRP system:

> onChange :: Eq a => ReadRef a -> (a -> CreateRef b) -> CreateRef (ReadRef b)



> onChange :: ReadRef (CreateRef b) -> CreateRef (ReadRef b)


## Semantics with examples

TODO


## Variations

> onChangeMemo :: Eq a => ReadRef a -> (a -> CreateRef (CreateRef b)) -> CreateRef (ReadRef b)

> onChangeAcc :: Eq a => b -> ReadRef a -> (b -> a -> CreateRef b) -> CreateRef (ReadRef b)


TODO


# Bindings to outer actions

    registerCallback :: Functor f => f (Modifier m ()) -> m (f (EffectM m ()))


> liftEffect :: ... a -> CreateRef a

## Resource handling

    onRegionStatusChange :: (RegionStatusChange -> m ()) -> m ()

data RegionStatusChange = Kill | Block | Unblock deriving (Eq, Ord, Show)

TODO


# Summary

TODO

## Comparison to existing Haskell FRP frameworks

reactive
reactive-banana
Elerea
FranTk
Sodium
Elm
netwire
yampa
iTask

TODO


## Extra diagrams


~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    Edge [arrowtail=inv, dir=both]
    A -> C [label = "k"]
    B -> C [label = "l"]
    Edge [style = dashed]
    D [style = dashed]
    D -> A [label = "k'"]
    D -> B [label = "l'"]
    A [label = "a :: A"]
    B [label = "b :: B"]
    C [label = "c :: C"]
    D [label = "d :: D"]
}
~~~~~~~~



~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    Edge [arrowtail=inv, dir=both]
    a -> b
    b -> c
    d -> b
    d -> e
}
~~~~~~~~

~~~~~~~~ {.dot}
digraph G {
    rankdir = BT
    Edge [arrowtail=inv, dir=both]
    Edge [style = dashed]
    x [style = dashed]
    x -> a
    x -> b
    x -> c
    x -> d
    x -> e
    x [label = "program state"]
}
~~~~~~~~



